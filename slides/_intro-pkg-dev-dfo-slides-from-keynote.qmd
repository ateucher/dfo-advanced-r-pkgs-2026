---
title: "Fundamentals of Package Development"
subtitle: "DFO - November 2024"
format: revealjs
execute:
  eval: false
  echo: true
---

## Welcome!

**Instructors:**

- Andy Teucher
  - [andyteucher.ca](https://andyteucher.ca)
  - GitHub: [ateucher](https://github.com/ateucher)
  - Mastodon: @andyteucher@fosstodon.org
- Sam Albers
  - [samalbers.science](https://samalbers.science)
  - GitHub: [boshek](https://github.com/boshek)

::: {.notes}
Thanks to Jaclyn and Shannon for arranging this.
:::

## Welcome!

This is a three-part course for people looking to learn how to build R packages in an efficient way, make them easy to maintain, and easy for users to use.

**Code of Conduct:**

- Treat everyone with respect
- Everyone should feel welcome

::: {.notes}
Cameras.
:::

## Sticky Notes

::: columns
::: {.column width="50%"}
**PINK**

I'm stuck, please send help
:::

::: {.column width="50%"}
**GREEN**

I'm good, let's move on
:::
:::

## Sticky Notes (online)

::: columns
::: {.column width="50%"}
**PINK = I'm stuck**

Use the Zoom Raise Hand reaction
:::

::: {.column width="50%"}
**GREEN = I'm good**

Use the Thumbs Up reaction
:::
:::

::: {.notes}
We'll try to help everyone keep up. Questions in the chat or raise hand. Big issues can use a breakout room with the other instructor. Try to keep discussions in the main room.
:::

## Discussions / Q & A

- Zoom Chat
- GitHub Discussions: <https://github.com/ateucher/pkg-dev-dfo-2024-11/discussions>

Open the welcome discussion and introduce yourself:

- Office/department, city/town
- Why you're here
- Share something you're good at

::: {.notes}
Paste link in chat. Open GitHub discussions, ask people to introduce themselves. Share screen doing it. Markdown syntax.
:::

## Resources

- **Prework:** <https://andyteucher.ca/pkg-dev-dfo-2024-11/setup.html>
- **Workshop website:** <https://andyteucher.ca/pkg-dev-dfo-2024-11/>
- **Cheatsheet:** <https://rstudio.github.io/cheatsheets/html/package-development.html>

::: {.notes}
Remind people about setup - which they should have done.
:::

# Day 1

## Schedule

| Time | Session |
|------|---------|
| 8:00 - 9:20 | Package Creation |
| 9:20 - 9:35 | Break |
| 9:35 - 10:55 | Git and GitHub |
| 10:55 - 11:10 | Break |
| 11:10 - 12:30 | Testing |

2024-11-04

# Package Creation

## Why make a package?

- Reuse your code across projects and share it with others
- Enforce a consistent interface around your work
- Bundle code with documentation and tests
- Distribute software in a reproducible way

::: {.notes}
A package is the fundamental unit of shareable R code. Even if you never share it publicly, packaging your own work enforces good habits.
:::

## Package structure

```
libminer/
  R/           <- Your R functions
  man/         <- Documentation (auto-generated)
  tests/       <- Tests
  DESCRIPTION  <- Package metadata
  NAMESPACE    <- Exports (auto-generated)
```

## Create a package

```{r}
create_package("~/Documents/libminer")
```

::: {.fragment}
This creates the package skeleton and opens a new RStudio project.
:::

## Add a function

```{r}
use_r("lib_summary")
```

::: {.fragment}
Creates `R/lib_summary.R` and opens it for editing.
:::

## Load your package

```{r}
load_all()
```

`Ctrl/Cmd+Shift+L` - use this constantly during development.

::: {.fragment}
- Simulates installing and loading the package
- Much faster than `install.packages()` + `library()`
- Makes all functions available for testing
:::

## Document your functions

```{r}
#' Summarise your installed package library
#'
#' @param path Path to the library. Defaults to the first library path.
#'
#' @return A data frame with one row per package.
#' @export
#'
#' @examples
#' lib_summary()
lib_summary <- function(path = .libPaths()[1]) {
  pkgs <- as.data.frame(installed.packages(path))
  pkgs[, c("Package", "Version", "LibPath")]
}
```

## Generate documentation

```{r}
document()
```

`Ctrl/Cmd+Shift+D`

::: {.fragment}
- Reads `#'` roxygen2 comments
- Creates `.Rd` files in `man/`
- Updates `NAMESPACE`
:::

## DESCRIPTION

```
Package: libminer
Title: Tools for Exploring your R Library
Version: 0.0.0.9000
Authors@R:
    person("First", "Last", email = "first.last@example.com",
           role = c("aut", "cre"))
Description: Functions for summarising and exploring installed packages.
License: MIT + file LICENSE
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.3.1
```

## Add a license

```{r}
use_mit_license()
```

::: {.fragment}
Adds `LICENSE` and `LICENSE.md` files and updates `DESCRIPTION`.

Other options: `use_gpl3_license()`, `use_ccby_license()`, `use_proprietary_license()`
:::

## NAMESPACE

Controls what your package exports (makes available to users) and what it imports from other packages.

```
# Generated by roxygen2: do not edit by hand

export(lib_summary)
```

::: {.fragment}
- Managed automatically by roxygen2
- Use `@export` to export a function
- Use `@importFrom pkg fun` to import from another package
- Never edit by hand
:::

## Check your package

```{r}
check()
```

`Ctrl/Cmd+Shift+E`

::: {.fragment}
Runs `R CMD check` - the same check CRAN runs. Aim for 0 errors, 0 warnings, 0 notes.
:::

## Install your package

```{r}
install()
```

::: {.fragment}
Installs the package into your R library. Now you can `library(libminer)` in any project.
:::

## Check, commit, push

```{r}
check()
```

Then commit your work:

```bash
git add -A
git commit -m "Add lib_summary()"
git push
```

# Git and GitHub

## Why version control?

- Track what changed, when, and why
- Revert to any previous version
- Collaborate without overwriting each other
- GitHub: share your code and build a portfolio

## Initialise git

```{r}
use_git()
```

::: {.fragment}
- Initialises a git repository
- Makes an initial commit
- Restarts RStudio with git pane active
:::

## Authenticate with GitHub

```{r}
# One-time setup: create a personal access token
create_github_token()

# Store the token in your system keychain
gitcreds_set()
```

::: {.notes}
`create_github_token()` opens the GitHub website with sensible default scopes selected. Copy the generated token and paste it when `gitcreds_set()` prompts you.
:::

## Connect to GitHub

```{r}
use_github()
```

::: {.fragment}
- Creates a GitHub repository
- Connects your local repo to GitHub
- Pushes your commits
:::

## PR workflow

```{r}
# Start a new branch for your work
pr_init("add-calculate-sizes")

# ... make changes, commit ...

# Push and open a pull request on GitHub
pr_push()
```

::: {.fragment}
After the PR is reviewed and merged:

```{r}
pr_finish()
```

:::

::: {.notes}
The PR workflow from usethis handles branching and PR creation in one step. This keeps the main branch clean and makes code review easier.
:::

## README

```{r}
use_readme_rmd()
```

::: {.fragment}
Creates `README.Rmd`. Edit it, then render:

```{r}
build_readme()
```

`README.md` is what GitHub displays on your repository page.
:::

## Continuous integration

```{r}
use_github_action("check-standard")
```

::: {.fragment}
Runs `R CMD check` automatically on every push and pull request - on Linux, macOS, and Windows.
:::

---

```{r}
use_github_action("check-standard")
```

Adds a badge to your README showing the current build status.

```markdown
[![R-CMD-check](https://github.com/you/libminer/actions/workflows/R-CMD-check.yaml/badge.svg)](...)
```

## Check, commit, push

```{r}
check()
```

Then commit your work and push to GitHub.

# Testing

## Why test?

- Confirm your code does what you think it does
- Catch regressions when you change code
- Tests are executable documentation
- Gives you confidence to refactor

## Initialise testthat

```{r}
use_testthat()
```

::: {.fragment}
Creates:

- `tests/testthat/` - directory for test files
- `tests/testthat.R` - script to run all tests
- Adds `testthat` to `Suggests` in `DESCRIPTION`
:::

## Create a test file

```{r}
use_test("lib_summary")
```

::: {.fragment}
Creates `tests/testthat/test-lib_summary.R` linked to `R/lib_summary.R`.
:::

## Basic structure

```{r}
test_that("lib_summary returns a data frame", {
  result <- lib_summary()
  expect_s3_class(result, "data.frame")
})
```

- One `test_that()` block = one behaviour
- Description should read like a sentence
- Multiple `expect_*()` calls per block are fine

## Common expectations

- `expect_equal()`: equality with numeric tolerance
- `expect_identical()`: exact equality
- `expect_s3_class()`: checks the class
- `expect_type()`: checks the type
- `expect_length()`: checks the length
- `expect_true()`, `expect_false()`: logical checks
- `expect_error()`, `expect_warning()`, `expect_message()`

See [testthat documentation](https://testthat.r-lib.org/reference/index.html)

## Test multiple behaviours

```{r}
test_that("lib_summary returns expected columns", {
  result <- lib_summary()

  expect_true("Package" %in% names(result))
  expect_true("Version" %in% names(result))
})

test_that("lib_summary only includes installed packages", {
  result <- lib_summary()
  expect_true(nrow(result) > 0)
})
```

## Run your tests

```{r}
test()
```

`Ctrl/Cmd+Shift+T`

::: {.fragment}
Or run a single `test_that()` block interactively with `Ctrl+Enter`.
:::

## Snapshot testing

Captures output and compares against a saved reference.

```{r}
test_that("lib_summary print method is stable", {
  expect_snapshot(
    lib_summary()
  )
})
```

::: {.fragment}
First run creates `tests/testthat/_snaps/lib_summary.md`. Subsequent runs fail if output changes.
:::

## Reviewing snapshots

```{r}
snapshot_review()  # interactive diff viewer
snapshot_accept()  # accept all changes
```

::: {.notes}
Always review snapshot changes before accepting. A failing snapshot means either a bug or an intentional change - you need to decide which.
:::

## Clean tests with withr

Tests should clean up after themselves. `withr` makes this easy.

```{r}
test_that("lib_summary respects library path option", {
  local_options(libminer.path = .libPaths()[1])
  result <- lib_summary()
  expect_s3_class(result, "data.frame")
})
```

::: {.fragment}
`local_options()` restores the original options when the test finishes - even if the test fails.
:::

## withr tools

- `local_options()` / `with_options()`: temporarily set options
- `local_tempfile()` / `local_tempdir()`: create temp files that are deleted on exit
- `local_seed()`: set a random seed and restore it
- `local_envvar()`: temporarily set environment variables
- `local_dir()`: temporarily change working directory

## Test coverage

```{r}
library(covr)
package_coverage()
```

::: {.fragment}
Shows what percentage of your code is executed by tests.

```{r}
report()         # Open HTML report
zero_coverage()  # Show untested lines
```

:::

## Coverage in CI

```{r}
use_github_action("test-coverage")
```

::: {.fragment}
Runs coverage on every push and reports results to [Codecov](https://codecov.io).
:::

## Check, commit, push

```{r}
check()
test()
```

Then commit and push.

# Day 1 complete!

# Day 2

## Schedule

| Time | Session |
|------|---------|
| 8:00 - 9:20 | Design Principles |
| 9:20 - 9:35 | Break |
| 9:35 - 10:55 | Dependencies |
| 10:55 - 11:10 | Break |
| 11:10 - 12:30 | CI and Wrapping Up |

2024-11-05

# Design Principles

## What makes good code?

- Readable: easy to understand what it does
- Correct: does what you intend
- Maintainable: easy to change

::: {.fragment}
We will look at: naming, code style, pure functions, the DRY principle, helper functions, arguments, and input validation.
:::

## Naming conventions

Use `snake_case` for everything in R:

```{r}
# Good
calculate_area <- function(length, width) { }
lib_summary <- function() { }

# Avoid
calculateArea <- function(Length, Width) { }
```

## Naming: functions as verbs

```{r}
# Good - functions do things
calculate_cpue()
filter_by_year()
plot_abundance()

# Avoid
cpue()         # What does this do?
fish_data()    # Is this a function or an object?
```

## Naming: objects as nouns

```{r}
# Good - objects are things
survey_data <- read_csv("survey.csv")
model_fit <- lm(y ~ x, data = df)

# Avoid
doReadingCSV <- read_csv("survey.csv")
```

## Code style

Consistent style makes code easier to read.

```{r}
# Inconsistent
x=1+2
y =sum(c(1,2,3) )

# Consistent
x <- 1 + 2
y <- sum(c(1, 2, 3))
```

::: {.fragment}
```{r}
styler::style_pkg()    # Auto-format your package
lintr::lint_package()  # Check for style issues
```

:::

## Pure functions

A pure function:

1. Always returns the same output for the same inputs
2. Has no side effects

```{r}
# Pure
add <- function(x, y) {
  x + y
}

# Not pure - depends on global state
multiplier <- 2
scale <- function(x) {
  x * multiplier
}
```

## Functions with side effects

```{r}
# Side effects: modifies global state
counter <- 0
increment <- function() {
  counter <<- counter + 1
}

# Side effects: reads from disk, prints output
load_data <- function(path) {
  cat("Loading", path, "\n")
  read.csv(path)
}
```

::: {.fragment}
Side effects are sometimes necessary, but prefer pure functions when possible. Easier to test and reason about.
:::

## The DRY principle

**D**on't **R**epeat **Y**ourself

```{r}
# Repetitive
sum_of_squares_2 <- 1^2 + 2^2
sum_of_squares_3 <- 1^2 + 2^2 + 3^2
sum_of_squares_4 <- 1^2 + 2^2 + 3^2 + 4^2
```

::: {.fragment}
Problems:
- Change the formula and you need to update every line
- Easy to introduce inconsistencies
- Hard to read and maintain
:::

## Identifying redundant code

Look for:

- Copy-pasted code with small variations
- The same expression computed multiple times
- Long functions that do many separate things

## Refactor to use functions

```{r}
# DRY version
square <- function(x) x^2

sum_of_squares <- function(n) {
  sum(square(seq_len(n)))
}

sum_of_squares(2)
sum_of_squares(3)
sum_of_squares(4)
```

## Helper functions

Small, focused functions that do one thing well.

```{r}
# Helper
square <- function(x) x^2

# Main function uses helper
sum_of_squares <- function(n) {
  sum(square(seq_len(n)))
}
```

::: {.fragment}
- Keep each function focused on one task
- Helper functions can be reused
- Easier to test individually
:::

## Your turn: helper functions in libminer

Extract repeated logic into a helper function.

```{r}
# Before: calculate_sizes has repetitive code
calculate_sizes <- function(path = .libPaths()[1]) {
  pkgs <- list.dirs(path, recursive = FALSE, full.names = TRUE)
  sizes <- sapply(pkgs, function(p) {
    files <- list.files(p, recursive = TRUE, full.names = TRUE)
    sum(file.size(files))
  })
  data.frame(package = basename(pkgs), size_bytes = sizes)
}
```

## Arguments

Three types of function arguments:

```{r}
my_function <- function(
    required_arg,           # Required: no default
    optional_arg = TRUE,    # Optional: has a default
    ...                     # Dots: passed to other functions
) { }
```

## Default argument values

Use defaults to make common cases easy.

```{r}
# Before
greet <- function(name, greeting) {
  paste(greeting, name)
}
greet("World", "Hello")
```

::: {.fragment}
```{r}
# After: sensible default
greet <- function(name, greeting = "Hello") {
  paste(greeting, name)
}

greet("World")          # "Hello World"
greet("World", "Hi")    # "Hi World"
```

:::

## Default argument values: documentation

Document defaults clearly:

```{r}
#' Summarise your installed package library
#'
#' @param path Path to the library. Defaults to the first
#'   element of [.libPaths()].
lib_summary <- function(path = .libPaths()[1]) {
  # ...
}
```

## Input checking and validation

Why validate inputs?

- Give users clear error messages
- Prevent confusing downstream errors
- Document your assumptions

```{r}
# Tools
is.numeric(), is.character(), is.logical()
length()
stopifnot()
stop()
```

## Bad inputs produce confusing errors

```{r}
calculate_area("a", 5)
#> Error in length * width: non-numeric argument to binary operator

calculate_area(-1, 5)
#> [1] -5  # Wrong! Silent bad result
```

::: {.fragment}
Your users will thank you for a clear error message.
:::

## Input checking with `stop()`

```{r}
calculate_area <- function(length, width) {
  if (!is.numeric(length)) {
    stop("`length` must be numeric, not ", class(length))
  }
  if (!is.numeric(width)) {
    stop("`width` must be numeric, not ", class(width))
  }
  if (any(length <= 0)) stop("`length` must be positive")
  if (any(width <= 0)) stop("`width` must be positive")

  length * width
}
```

## Your turn: input checking

Add input validation to `lib_summary()`:

- `path` must be a character string
- `path` must point to an existing directory

```{r}
lib_summary <- function(path = .libPaths()[1]) {
  # Add checks here

  pkgs <- as.data.frame(installed.packages(path))
  pkgs[, c("Package", "Version", "LibPath")]
}
```

## Helper functions for validation

Extract validation into a reusable helper:

```{r}
# tests/testthat/helper.R or R/utils.R
validate_path <- function(path) {
  if (!is.character(path)) {
    stop("`path` must be a character string, not ", class(path))
  }
  if (!dir.exists(path)) {
    stop("`path` does not exist: ", path)
  }
  invisible(path)
}
```

## Using the validation helper

```{r}
calculate_sizes <- function(path = .libPaths()[1]) {
  validate_path(path)

  pkgs <- list.dirs(path, recursive = FALSE, full.names = TRUE)
  sizes <- sapply(pkgs, function(p) {
    files <- list.files(p, recursive = TRUE, full.names = TRUE)
    sum(file.size(files))
  })
  data.frame(package = basename(pkgs), size_bytes = sizes)
}

lib_summary <- function(path = .libPaths()[1]) {
  validate_path(path)

  pkgs <- as.data.frame(installed.packages(path))
  pkgs[, c("Package", "Version", "LibPath")]
}
```

## Your turn: Tidyversify libminer input checking

Add input validation to `lib_summary()` using your `validate_path()` helper.

Then: `check()`, commit, and push.

## Code style and readability

Clear code reads like prose:

```{r}
# Hard to read
f<-function(x,y){if(x>0){return(x+y)}else{return(x-y)}}

# Readable
adjust_value <- function(x, y) {
  if (x > 0) {
    x + y
  } else {
    x - y
  }
}
```

::: {.fragment}
- One expression per line
- Whitespace around operators
- Descriptive names
:::

## Check, commit, push

```{r}
check()
test()
```

Then commit and push.

# Dependencies

## Why manage dependencies?

Your package may need functions from other packages.

- Declare them in `DESCRIPTION`
- R will install them when users install your package
- Helps users understand what your package needs

## Imports vs Suggests

| | `Imports` | `Suggests` |
|-|-----------|------------|
| Required? | Yes, always | No, optional |
| Use case | Core functionality | Tests, vignettes, optional features |

## Add a dependency

```{r}
use_package("dplyr")
```

::: {.fragment}
Adds `dplyr` to `Imports` in `DESCRIPTION`:

```
Imports:
    dplyr
```

:::

## Add a suggested dependency

```{r}
use_package("ggplot2", type = "Suggests")
```

::: {.fragment}
```
Suggests:
    ggplot2,
    testthat (>= 3.0.0)
```

:::

## Using package functions: `::`

When a package is in `Imports`, use `::` to call its functions:

```{r}
lib_summary_tidy <- function(path = .libPaths()[1]) {
  validate_path(path)

  pkgs <- as.data.frame(installed.packages(path))
  dplyr::select(pkgs, Package, Version, LibPath)
}
```

## Importing specific functions

For functions you use many times, import them:

```{r}
use_import_from("dplyr", "select")
use_import_from("dplyr", "filter")
use_import_from("dplyr", "mutate")
```

::: {.fragment}
Adds `@importFrom` tags to your package documentation file and updates `NAMESPACE`:

```
importFrom(dplyr,filter)
importFrom(dplyr,mutate)
importFrom(dplyr,select)
```

:::

## Suggested packages in code

```{r}
plot_lib_sizes <- function(path = .libPaths()[1]) {
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package 'ggplot2' is needed. Install with: install.packages('ggplot2')")
  }

  sizes <- calculate_sizes(path)
  ggplot2::ggplot(sizes, ggplot2::aes(x = package, y = size_bytes)) +
    ggplot2::geom_col()
}
```

## Check, commit, push

```{r}
check()
test()
```

Then commit and push.

# CI and Wrapping Up

## Continuous integration recap

```{r}
use_github_action("check-standard")  # R CMD check
use_github_action("test-coverage")   # Code coverage
```

::: {.fragment}
Every push triggers automated checks. Green badges signal a healthy package.
:::

## The development loop

1. `use_r()` - create a new function file
2. Write your function
3. `load_all()` - load and test interactively
4. `use_test()` - create a test file
5. Write tests
6. `test()` - run tests
7. `document()` - update documentation
8. `check()` - full package check
9. Commit and push

## Check, commit, push

```{r}
check()
test()
```

Then commit and push to close out Day 2.

# Day 2 complete!

# Day 3

## Welcome back

Sticky notes: what is one thing you want to cover or clarify today?

## Schedule

| Time | Session |
|------|---------|
| 8:00 - 9:20 | Website Creation and Tidyverse |
| 9:20 - 9:35 | Break |
| 9:35 - 10:55 | Tidyverse Part 2 |
| 10:55 - 11:10 | Break |
| 11:10 - 12:30 | Communicating with Users and Distribution |

2024-11-06

# Website Creation and Long-Form Documentation

## Why make a website?

- Beautiful, searchable documentation for free
- Reference pages for every exported function
- Long-form articles (vignettes)
- Easy to share with users

## Set up pkgdown

```{r}
use_pkgdown_github_pages()
```

::: {.fragment}
- Sets up pkgdown configuration
- Configures GitHub Pages deployment
- Adds a GitHub Actions workflow

See [pkgdown.r-lib.org](https://pkgdown.r-lib.org) for more.
:::

## Vignettes: long-form documentation

```{r}
use_vignette("introduction")   # Included with package
use_article("advanced-usage")  # pkgdown-only (website article)
```

::: {.fragment}
Both create `.Rmd` files in `vignettes/`.

- Vignettes are built and distributed with the package
- Articles are only on the pkgdown website
:::

::: {.notes}
pkgdown has experimental Quarto support, but `.Rmd` is the most reliable option for vignettes right now.
:::

## Vignette dependencies

Packages used in vignettes must be in `Suggests`:

```{r}
use_package("ggplot2", type = "Suggests")
```

::: {.fragment}
And your vignette YAML should include:

```yaml
VignetteBuilder: knitr
```

`R CMD check` will run vignettes and report errors.
:::

## The `eval` chunk option

Some vignette code can't run in all environments:

```{r}
#| eval: !expr requireNamespace("ggplot2", quietly = TRUE)
library(ggplot2)
# plotting code
```

```{r}
#| eval: !expr nchar(Sys.getenv("API_KEY")) > 0
# code that needs an API key
```

```{r}
#| eval: !expr file.exists("local-data.csv")
# code that needs a local file
```

::: {.notes}
This pattern from the gargle package uses `can_decrypt()` to conditionally run code that needs credentials. The same idea applies to any environment-specific dependency.
:::

# Using the Tidyverse in Your Package

## How many people use the tidyverse?

::: {.notes}
Quick show of hands before diving in. This section is relevant whether or not you use tidyverse functions, because understanding tidy evaluation helps you debug confusing errors.
:::

## Learning objectives

- Understand **data masking** and the `{{ embrace }}` operator
- Use **tidy select** helpers
- Use **dynamic dots** for flexible column naming

## Tidy evaluation: motivation

Why do tidyverse functions feel different?

```{r}
# Intuitive - bare column names
dplyr::filter(mtcars, cyl == 4)

# Base R - need to repeat the data frame
mtcars[mtcars$cyl == 4, ]
subset(mtcars, cyl == 4)
```

::: {.fragment}
Tidy eval is what makes `filter(mtcars, cyl == 4)` work - `cyl` refers to the column, not any R variable named `cyl`.
:::

## Families of tidy-eval functions

| Family | Functions | How columns are specified |
|--------|-----------|--------------------------|
| Data masking | `mutate`, `filter`, `group_by`, `summarise` | Bare column names evaluated in data context |
| Tidy select | `select`, `pull`, `rename` | Column names plus tidyselect helpers |

## Data masking: two types of variables

```{r}
# Environment variable - lives in your R session
x <- c(1, 2, 3)

# Data variable - lives inside a data frame
mtcars$cyl  # cyl is a data variable
```

::: {.fragment}
Data masking lets you refer to data variables without the `$`:

```{r}
filter(mtcars, cyl == 4)  # cyl is a data variable
```

:::

## Data masking in context

```{r}
# cyl refers to the column in mtcars
filter(mtcars, cyl == 4)

# group_by and summarise both see data variables
mtcars |>
  group_by(cyl) |>
  summarise(mean_mpg = mean(mpg))
```

## Identify env-variables vs data-variables

```{r}
# What is cyl here?
cyl <- 6                          # env-variable: the number 6
filter(mtcars, cyl == 4)          # data-variable: the column

# What about here?
my_col <- "cyl"                   # env-variable: the string "cyl"
filter(mtcars, my_col == 4)       # data-variable? No! Looks for column named my_col
```

## Programming with data variables: the problem

```{r}
var_summary <- function(df, var) {
  df |>
    group_by(var) |>
    summarise(mean = mean(var))
}

var_summary(mtcars, mpg)
#> Error in `group_by()`:
#> ! Must group by variables found in `.data`.
#> x Column `var` is not found.
```

::: {.fragment}
`var` is an env-variable (a function argument), but `group_by` looks for a data-variable named `var`.
:::

## The solution: `{{ embrace }}`

```{r}
var_summary <- function(df, var) {
  df |>
    group_by({{ var }}) |>
    summarise(mean = mean({{ var }}))
}

var_summary(mtcars, mpg)
#> # A tibble: 3 x 2
#>     cyl  mean
#>   <dbl> <dbl>
#> 1     4  26.7
#> ...
```

::: {.fragment}
`{{ var }}` tells dplyr "treat `var` as a data variable, not an env-variable".
:::

## Using `.data[[]]` for character arguments

```{r}
var_summary <- function(df, var) {
  df |>
    group_by(.data[[var]]) |>
    summarise(mean = mean(.data[[var]]))
}

# Now accepts a string
var_summary(mtcars, "mpg")
```

::: {.fragment}
Use `.data[[var]]` when `var` is a character string, not a bare column name.
:::

## The `.data` pronoun

```{r}
# Explicit: always refers to the column, not any env-variable
filter(mtcars, .data$cyl == 4)

# Ambiguous if you have an env-variable named cyl
cyl <- 6
filter(mtcars, cyl == 4)      # Refers to the column (data-variable wins)
filter(mtcars, .data$cyl == 4) # Explicit: definitely the column
```

## Your turn: `height_sum()`

Write a function that summarises starwars characters by a grouping variable:

```{r}
height_sum <- function(df, group_var) {
  df |>
    group_by({{ group_var }}) |>
    summarise(mean_height = mean(height, na.rm = TRUE))
}

height_sum(starwars, species)
```

## Multiple grouping with `...`

```{r}
height_sum <- function(df, ...) {
  df |>
    group_by(...) |>
    summarise(mean_height = mean(height, na.rm = TRUE))
}

height_sum(starwars, species, gender)
```

::: {.fragment}
`...` passes multiple bare column names through to `group_by()` without any special syntax.
:::

## Data masking summary

| Situation | Syntax |
|-----------|--------|
| Pass a bare column name | `{{ var }}` |
| Refer to a column directly | `.data$col` |
| Use a string column name | `.data[[var]]` |
| Pass multiple column names | `...` |

Works with: `arrange()`, `filter()`, `group_by()`, `mutate()`, `summarise()`

## Name injection with dynamic dots

Dynamically create new column names with `:=`:

```{r}
# {glue} syntax for string variable
new_name <- "mpg_mean"
mtcars |>
  summarise("{new_name}" := mean(mpg))

# {{ embrace }} syntax for function argument variable
my_summary <- function(df, var) {
  df |>
    summarise("{{var}}_mean" := mean({{ var }}))
}
my_summary(mtcars, mpg)
#> # A tibble: 1 x 1
#>   mpg_mean
```

## Import `:=` from rlang

```{r}
usethis::use_import_from("rlang", ":=")
```

::: {.fragment}
This adds the walrus operator to your package's imports so you can use it without `rlang::`:

```{r}
my_summary <- function(df, var) {
  df |>
    summarise("{{var}}_mean" := mean({{ var }}))
}
```

:::

## Your turn: `dynamic_sum()`

Write a function that summarises starwars and creates dynamic column names:

```{r}
dynamic_sum <- function(df, var) {
  df |>
    summarise(
      "{{var}}_mean" := mean({{ var }}, na.rm = TRUE),
      "{{var}}_sd"   := sd({{ var }}, na.rm = TRUE)
    )
}

dynamic_sum(starwars, height)
```

## Tidy selection: selecting columns

```{r}
# Bare names
select(mtcars, mpg, cyl, hp)

# tidyselect helpers
select(mtcars, starts_with("c"))
select(mtcars, ends_with("p"))
select(mtcars, where(is.numeric))
```

## Tidy selection in functions

```{r}
# This does NOT work with a character vector
cols <- c("mpg", "cyl")
select(mtcars, cols)
#> Error: object 'cols' not found

# Use all_of() or any_of()
select(mtcars, all_of(cols))   # Error if any column missing
select(mtcars, any_of(cols))   # Silently skips missing columns
```

## `all_of()` vs `any_of()`

```{r}
cols <- c("mpg", "cyl", "not_a_column")

# all_of() - strict
select(mtcars, all_of(cols))
#> Error: Can't subset columns that don't exist.

# any_of() - permissive
select(mtcars, any_of(cols))
#> # A tibble with mpg and cyl only
```

::: {.fragment}
Use `all_of()` when missing columns are a bug. Use `any_of()` when they may legitimately be absent.
:::

## `dplyr::across()`

Apply functions across multiple columns inside data-masking verbs:

```{r}
# Summarise all numeric columns
mtcars |>
  summarise(across(where(is.numeric), mean))

# Multiple summary functions
mtcars |>
  summarise(across(c(mpg, cyl), list(mean = mean, sd = sd)))

# Mutate multiple columns
mtcars |>
  mutate(across(starts_with("c"), ~ .x * 2))
```

## Your turn: Tidyversify libminer

Modify `lib_summary()` to use dplyr for data manipulation:

```{r}
lib_summary <- function(path = .libPaths()[1]) {
  validate_path(path)

  pkgs <- as.data.frame(installed.packages(path))

  # Use dplyr::select() and dplyr::arrange()
  pkgs |>
    dplyr::select(Package, Version, LibPath) |>
    dplyr::arrange(Package)
}
```

Then `check()`, commit, and push.

# Break

# Communicating with Your User

## Signaling conditions

Three levels of severity:

| Condition | Function | Severity |
|-----------|----------|----------|
| Error | `stop()` / `rlang::abort()` | Highest - stops execution |
| Warning | `warning()` / `rlang::warn()` | Middle - execution continues |
| Message | `message()` / `rlang::inform()` | Lowest - informational |

## Signaling conditions: code

```{r}
# Errors
stop("Something went wrong")
rlang::abort("Something went wrong")

# Warnings
warning("Something might be wrong")
rlang::warn("Something might be wrong")

# Messages
message("FYI: processing your data")
rlang::inform("FYI: processing your data")
```

## Conditions are better than `cat()`

```{r}
# Bad: cat() output can't be suppressed or caught
cat("Loading data...\n")

# Good: message() can be suppressed
message("Loading data...")
suppressMessages(my_function())

# Can also be caught programmatically
withCallingHandlers(
  my_function(),
  message = function(m) {
    log_message(conditionMessage(m))
    invokeRestart("muffleMessage")
  }
)
```

::: {.fragment}
`suppressWarnings()` works the same way for warnings. `tryCatch()` catches errors.
:::

## `{cli}`: beautiful command line interfaces

The `cli` package makes it easy to produce rich, consistent user-facing output.

```{r}
use_package("cli")
```

::: {.fragment}
Features:
- Semantic markup elements
- glue-style interpolation
- Automatic pluralisation
- Theming
- Progress bars
- Rich text in conditions
:::

## usethis's UI is built with cli

```{r}
ui_bullets(c(
  "v" = "Setting active project to {.path {path}}",
  "i" = "Leaving {.path {old}} unchanged.",
  "x" = "Can't connect to {.url {url}}"
))
```

## cli's greatest hits

```{r}
# Alerts
cli_alert("A plain alert")
cli_alert_success("Operation succeeded")
cli_alert_warning("Something might be wrong")
cli_alert_danger("Something went wrong")
cli_alert_info("FYI: doing something")

# Conditions
cli_inform("Informational message")
cli_warn("Warning message")
cli_abort("Error message - stops execution")
```

## Interpolation

Use `{}` to embed R values:

```{r}
pkgs <- c("ggplot2", "dplyr")
cli_text("Will install the {pkgs} package")
#> Will install the ggplot2 and dplyr package
```

## Pluralisation

Use `{?s}` for automatic plural/singular:

```{r}
nfiles <- 3
cli_text("Found {nfiles} file{?s}")
#> Found 3 files

nfiles <- 1
cli_text("Found {nfiles} file{?s}")
#> Found 1 file
```

## Pluralisation and concatenation

```{r}
pkgs <- c("ggplot2", "dplyr", "tidyr")
cli_text("Will install {pkgs} package{?s}")
#> Will install ggplot2, dplyr, and tidyr packages

pkgs <- "ggplot2"
cli_text("Will install {pkgs} package{?s}")
#> Will install ggplot2 package
```

## Inline text formatting

```{r}
cli_abort(c(
  "{.arg x} must be numeric",
  "i" = "You supplied a {.cls {class(x)}}"
))

cli_inform("Run {.fun devtools::check} before submitting")
cli_inform("See {.file DESCRIPTION} for package metadata")
cli_inform("Visit {.url https://r-pkgs.org} for more")
cli_inform("Set {.envvar R_LIBS_USER} to change your library path")
```

## Inline formatting reference

| Tag | Renders as |
|-----|------------|
| `{.arg x}` | Argument name |
| `{.fn fun}` | Function name |
| `{.pkg pkg}` | Package name |
| `{.file path}` | File path (with hyperlink) |
| `{.url url}` | URL (with hyperlink) |
| `{.href [text](url)}` | Hyperlink with custom text |
| `{.envvar VAR}` | Environment variable |
| `{.code x <- 1}` | Inline code |
| `{.emph text}` | Emphasised text |
| `{.strong text}` | Strong text |

## Help topic links

```{r}
cli_abort(
  "Something went wrong. See {.fun cli::cli_abort} for details."
)
```

::: {.fragment}
In RStudio and Positron, `{.fun pkg::function}` renders as a clickable link that opens the help page.
:::

## File hyperlinks

```{r}
cli_inform("Modifying {.file DESCRIPTION}")
cli_inform("Created {.file {path}}")
```

## URLs and hyperlinks

```{r}
cli_inform("See {.url https://r-pkgs.org}")
cli_inform("See {.href [R Packages](https://r-pkgs.org)}")
```

## Formatting plus interpolation

Use `{{` and `}}` to interpolate inside a formatting tag:

```{r}
pkg_name <- "dplyr"
cli_inform("Loading {.pkg {pkg_name}}")
#> Loading dplyr

path <- "R/utils.R"
cli_abort("Can't find {.file {path}}")
#> Error: Can't find R/utils.R
```

## Your turn: convert libminer to cli

Choose a package you know. Study its user-facing messages.

1. Add `cli` as a dependency: `use_package("cli")`
2. Convert `stop()` calls to `cli_abort()`
3. Convert `message()` calls to `cli_inform()`
4. Add inline formatting to make messages informative

Then `check()`, commit, and push.

# Break


# DFO Package Discussion

# Thank You!

## Resources

- [r-pkgs.org](https://r-pkgs.org) - R Packages book (Hadley Wickham & Jennifer Bryan)
- [happygitwithr.com](https://happygitwithr.com) - Git and GitHub for R users
- [posit.co/resources/cheatsheets/](https://posit.co/resources/cheatsheets/) - Package development cheat sheet
- [community.rstudio.com/c/package-development](https://community.rstudio.com/c/package-development) - Community forum
- [design.tidyverse.org](https://design.tidyverse.org) - Tidyverse design guide
- [tidydesign.substack.com](https://tidydesign.substack.com)

## Attribution

- https://github.com/posit-conf-2024/pkg-dev
- https://cli.r-lib.org/articles/index.html
- https://adv-r.hadley.nz/conditions.html
- https://rstudio-conf-2022.github.io/build-tidy-tools/
- https://dplyr.tidyverse.org/articles/programming.html
- https://design.tidyverse.org/

## Course materials

[https://andyteucher.ca/pkg-dev-dfo-2024-11](https://andyteucher.ca/pkg-dev-dfo-2024-11)

Released under an open license: Creative Commons Attribution 4.0 International - you are free to use, reuse, and remix (with attribution).

## Survey

Your feedback is crucial! Please complete the post-workshop survey.

Data from the survey informs curriculum and format decisions for future workshops, and we really appreciate you taking the time to provide it.
